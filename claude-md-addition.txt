
### Session Logging Protocol

**Purpose**: Continuous session logging mitigates context pressure degradation by capturing insights when AI quality is optimal (low pressure), enabling high-quality handoffs even when called at 95%+ context utilization.

**Key Insight**: Context pressure degrades AI quality as the conversation approaches saturation. By logging throughout the session at low pressure (20-80%), we capture rich detail when quality is high, then synthesize handoffs from logs when pressure is critical.

#### When to Log

Log after significant events during your session:

1. **After fixing bugs** - Error discovered, root cause, solution applied
2. **After implementing features** - What was added, why it was needed
3. **After making decisions** - What was decided, why, alternatives considered
4. **After discovering insights** - Patterns noticed, gotchas learned, optimizations found
5. **After git operations** - Commits made, branches changed, merges completed
6. **After achievements** - Features complete, tests passing, milestones reached

**Logging Frequency**: Aim for 5-10 log entries per session. Keep entries concise (1-2 sentences).

#### Event Categories

Use these categories to organize session events:

**fix** - Bug fixes and error resolution
- **What to log**: Error encountered, root cause identified, solution applied
- **Example**: "Fixed TypeScript compilation error in session-logger.ts caused by missing import. Added fs-extra import."
- **Impact**: Usually high (blocks progress) or medium (quality issue)

**feature** - New functionality implementation
- **What to log**: What was added and why it was needed
- **Example**: "Implemented logEvent() function with auto-pressure capture. Enables continuous logging throughout session."
- **Impact**: Usually high (core feature) or medium (enhancement)

**decision** - Key architectural or design decisions
- **What to log**: What was decided, why, what alternatives were considered
- **Example**: "Decided to use Markdown format for session logs instead of JSON. Better readability and git-friendly diffs."
- **Impact**: Usually high (affects architecture) or medium (affects implementation)

**insight** - Patterns, gotchas, learnings discovered
- **What to log**: Pattern noticed, gotcha learned, optimization found
- **Example**: "Discovered that Set objects don't serialize to JSON. Using Array.from() for filesAffected in log output."
- **Impact**: Usually medium (helps future work) or low (nice to know)

**git** - Git operations and version control
- **What to log**: Commits made, branches changed, merges completed
- **Example**: "Committed Phase 2 implementation with 3 new files. Branch: feature/adr-033-phase2-ai-protocol."
- **Impact**: Usually low (tracking) or medium (major milestone)

**achievement** - Milestones and completions
- **What to log**: Features complete, tests passing, goals achieved
- **Example**: "All integration tests passing. Session logging protocol fully functional."
- **Impact**: Usually high (major milestone) or medium (minor completion)

#### Logging Format

Each log entry follows this format:

```markdown
### HH:MM - [Category]
Brief description (1-2 sentences focusing on WHY not WHAT)
Files: file.ts:123, other.ts:456
Impact: high|medium|low | Pressure: XX%
```

**Example Log Entries**:

```markdown
### 14:32 - [fix]
Fixed async/await issue in loadSessionLog causing silent failures. Root cause: missing await on fs.readFile.
Files: session-logger.ts:125
Impact: high | Pressure: 35%

### 15:18 - [feature]
Implemented automatic pressure capture in logEvent(). Eliminates manual pressure tracking burden.
Files: session-logger.ts:87, session-logger.ts:428
Impact: medium | Pressure: 52%

### 16:03 - [decision]
Chose to append events incrementally vs rewriting entire file. Better performance and prevents data loss on crashes.
Files: session-logger.ts:248
Impact: high | Pressure: 68%

### 16:45 - [insight]
Discovered that Markdown parsing regex needs multiline flag for event extraction. Pattern: /### (\d{2}:\d{2}) - \[(.*?)\]/gm
Files: session-logger.ts:356
Impact: low | Pressure: 79%

### 17:20 - [achievement]
Phase 2 implementation complete with all tests passing. Ready for integration testing.
Files: session-logger.ts, session-logging.test.ts
Impact: high | Pressure: 88%
```

#### Integration with Context Reflexes

Session logging integrates seamlessly with existing Context Reflexes. When reflexes trigger, log the event:

**"Why Am I Doing This?" Reflex** → Log as decision
- Captures alignment moments and goal clarifications
- Example: "Refocused on core logging functionality. Deferred advanced pressure monitoring to Phase 3."

**"Have We Done This Before?" Reflex** → Log as insight (pattern recognition)
- Captures pattern discoveries and reuse opportunities
- Example: "This event categorization mirrors the insight types in types/session.ts. Maintaining consistency."

**"Something Feels Off" Reflex** → Log as fix or insight (gotcha)
- Captures confusion resolution and tricky issues discovered
- Example: "File paths must be absolute in Windows. Using path.join() instead of string concatenation."

**"Update My Understanding" Reflex** → Log as insight (learning)
- Captures key learnings and discoveries
- Example: "Learned that async fs operations need proper error handling. Added try-catch blocks throughout."

#### Logging Guidelines

**DO:**
- Keep descriptions to 1-2 sentences maximum
- Focus on WHY something was done, not WHAT was done
- Include file paths with line numbers when relevant
- Choose appropriate impact levels honestly
- Log immediately after the event (while context is fresh)
- Use natural language, not mechanical reporting

**DON'T:**
- Write lengthy paragraphs (defeats the purpose of concise logging)
- Log trivial actions (every file save, every minor edit)
- Duplicate information (log once per unique insight)
- Delay logging until end of session (defeats pressure mitigation)
- Include sensitive data (credentials, API keys, PII)

#### Logging in Practice

**Typical Session Flow**:

```
14:00 - Session starts (pressure: 15%)
14:32 - Fix authentication bug → Log [fix]
15:18 - Add new endpoint → Log [feature]
16:03 - Decide on caching strategy → Log [decision]
16:45 - Discover framework quirk → Log [insight]
17:20 - Tests passing → Log [achievement]
17:30 - Commit changes → Log [git]
17:45 - Call handoff (pressure: 92%)
       → Synthesize from 6 logged events
       → High-quality handoff despite high pressure
```

**Using the Logging API**:

```typescript
import { logEvent } from './utils/session-logger.js';

// After fixing a bug
await logEvent('fix', 'Resolved race condition in session initialization by adding mutex lock', {
  files: ['session-logger.ts:89'],
  impact: 'high'
});

// After implementing a feature
await logEvent('feature', 'Added archive() method to preserve completed sessions for team review', {
  files: ['session-logger.ts:195', 'session-logger.ts:223'],
  impact: 'medium'
});

// After making a decision
await logEvent('decision', 'Chose event-driven logging over periodic snapshots for better context alignment', {
  impact: 'high'
});

// After discovering an insight
await logEvent('insight', 'Git operations work better with absolute paths in cross-platform environments', {
  files: ['helpers.ts:45'],
  impact: 'low'
});
```

#### Benefits of Session Logging

1. **Higher Quality Handoffs** - Rich detail captured at low pressure (20-80%), synthesized at high pressure (90%+)
2. **Reduced Token Usage** - Synthesis requires far fewer tokens than full generation
3. **Timeline Preservation** - Exact chronology of session decisions and discoveries
4. **Team Learning** - Other developers can review session logs to understand "why"
5. **Context Continuity** - Future sessions benefit from captured insights
6. **Pressure Mitigation** - Inverts the quality curve by front-loading capture

**Quality Comparison**:

```
WITHOUT Logging:
- Handoff called at 92% pressure
- AI quality: 65% (degraded)
- Handoff quality: Generic, misses nuance
- Token cost: ~3000 tokens

WITH Logging:
- 6 events logged at 35-79% pressure
- AI quality during logging: 90-100%
- Handoff synthesized from rich logs
- Handoff quality: Detailed, preserves decisions
- Token cost: ~1500 tokens (50% savings)
```

