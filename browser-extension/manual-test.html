<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ginko Extension Manual Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .test-section {
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .test-section h2 {
            margin-top: 0;
            color: #333;
        }
        .test-button {
            background-color: #6366f1;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        .test-button:hover {
            background-color: #5856eb;
        }
        .test-result {
            background-color: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .success { color: #22c55e; }
        .error { color: #ef4444; }
        .warning { color: #f59e0b; }
        .info { color: #3b82f6; }
    </style>
</head>
<body>
    <h1>Ginko Extension Manual Test Suite</h1>
    <p>This page provides manual testing tools for the Ginko Chrome extension. Open this page while the extension is loaded to test various features.</p>
    
    <div class="test-section">
        <h2>üîç Extension Detection Test</h2>
        <p>Test if the extension is properly loaded and can communicate with this page.</p>
        <button class="test-button" onclick="testExtensionPresence()">Test Extension Presence</button>
        <div id="extension-result" class="test-result"></div>
    </div>

    <div class="test-section">
        <h2>üìã Clipboard API Test</h2>
        <p>Test clipboard functionality (requires user gesture).</p>
        <button class="test-button" onclick="testClipboard()">Test Clipboard Write</button>
        <button class="test-button" onclick="testClipboardRead()">Test Clipboard Read</button>
        <div id="clipboard-result" class="test-result"></div>
    </div>

    <div class="test-section">
        <h2>üíæ Storage API Test</h2>
        <p>Test localStorage and sessionStorage access.</p>
        <button class="test-button" onclick="testStorage()">Test Storage APIs</button>
        <div id="storage-result" class="test-result"></div>
    </div>

    <div class="test-section">
        <h2>üîí CSP Compliance Test</h2>
        <p>Test Content Security Policy compliance by attempting various operations.</p>
        <button class="test-button" onclick="testCSPCompliance()">Test CSP Compliance</button>
        <div id="csp-result" class="test-result"></div>
    </div>

    <div class="test-section">
        <h2>üéØ DOM Manipulation Test</h2>
        <p>Test DOM access and manipulation capabilities.</p>
        <button class="test-button" onclick="testDOMAccess()">Test DOM Access</button>
        <div id="dom-result" class="test-result"></div>
    </div>

    <div class="test-section">
        <h2>üöÄ Performance Test</h2>
        <p>Test performance impact of extension operations.</p>
        <button class="test-button" onclick="testPerformance()">Test Performance</button>
        <div id="performance-result" class="test-result"></div>
    </div>

    <script>
        let testResults = {};

        function log(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            const timestamp = new Date().toLocaleTimeString();
            const className = type;
            element.innerHTML += `<span class="${className}">[${timestamp}] ${message}</span>\n`;
            element.scrollTop = element.scrollHeight;
        }

        function testExtensionPresence() {
            const resultId = 'extension-result';
            document.getElementById(resultId).innerHTML = '';
            
            log(resultId, 'Testing extension presence...', 'info');
            
            // Test 1: Check if extension APIs are available
            if (typeof chrome !== 'undefined' && chrome.runtime) {
                log(resultId, '‚úÖ Chrome extension APIs available', 'success');
                
                // Test 2: Try to get extension ID
                if (chrome.runtime.id) {
                    log(resultId, `‚úÖ Extension ID: ${chrome.runtime.id}`, 'success');
                } else {
                    log(resultId, '‚ö†Ô∏è Extension ID not accessible', 'warning');
                }
                
                // Test 3: Check for Ginko debug objects
                if (typeof window.GinkoDebug !== 'undefined') {
                    log(resultId, '‚úÖ Ginko debug interface found', 'success');
                    log(resultId, `Available methods: ${Object.keys(window.GinkoDebug).join(', ')}`, 'info');
                } else {
                    log(resultId, '‚ö†Ô∏è Ginko debug interface not found (may not be on Claude.ai)', 'warning');
                }
            } else {
                log(resultId, '‚ùå Chrome extension APIs not available', 'error');
            }
            
            testResults.extensionPresence = true;
        }

        async function testClipboard() {
            const resultId = 'clipboard-result';
            document.getElementById(resultId).innerHTML = '';
            
            log(resultId, 'Testing clipboard functionality...', 'info');
            
            // Test clipboard write
            try {
                const testText = `Ginko clipboard test - ${new Date().toISOString()}`;
                await navigator.clipboard.writeText(testText);
                log(resultId, '‚úÖ Clipboard write successful', 'success');
                log(resultId, `Written text: "${testText}"`, 'info');
                testResults.clipboardWrite = true;
            } catch (error) {
                log(resultId, `‚ùå Clipboard write failed: ${error.message}`, 'error');
                testResults.clipboardWrite = false;
                
                // Try fallback method
                try {
                    const textArea = document.createElement('textarea');
                    textArea.value = 'Ginko fallback test';
                    document.body.appendChild(textArea);
                    textArea.select();
                    const success = document.execCommand('copy');
                    document.body.removeChild(textArea);
                    
                    if (success) {
                        log(resultId, '‚úÖ Fallback clipboard method successful', 'success');
                    } else {
                        log(resultId, '‚ùå Fallback clipboard method failed', 'error');
                    }
                } catch (fallbackError) {
                    log(resultId, `‚ùå Fallback method error: ${fallbackError.message}`, 'error');
                }
            }
        }

        async function testClipboardRead() {
            const resultId = 'clipboard-result';
            
            // Test clipboard read (requires user gesture)
            try {
                const text = await navigator.clipboard.readText();
                log(resultId, '‚úÖ Clipboard read successful', 'success');
                log(resultId, `Read text: "${text.substring(0, 100)}${text.length > 100 ? '...' : ''}"`, 'info');
                testResults.clipboardRead = true;
            } catch (error) {
                log(resultId, `‚ö†Ô∏è Clipboard read failed (expected): ${error.message}`, 'warning');
                log(resultId, 'Note: Clipboard read requires user gesture and may be restricted', 'info');
                testResults.clipboardRead = false;
            }
        }

        function testStorage() {
            const resultId = 'storage-result';
            document.getElementById(resultId).innerHTML = '';
            
            log(resultId, 'Testing storage APIs...', 'info');
            
            // Test localStorage
            try {
                const testKey = 'ginko_test_' + Date.now();
                const testValue = 'test_value_' + Math.random();
                
                localStorage.setItem(testKey, testValue);
                const retrieved = localStorage.getItem(testKey);
                localStorage.removeItem(testKey);
                
                if (retrieved === testValue) {
                    log(resultId, '‚úÖ localStorage read/write successful', 'success');
                    testResults.localStorage = true;
                } else {
                    log(resultId, '‚ùå localStorage data mismatch', 'error');
                    testResults.localStorage = false;
                }
            } catch (error) {
                log(resultId, `‚ùå localStorage failed: ${error.message}`, 'error');
                testResults.localStorage = false;
            }
            
            // Test sessionStorage
            try {
                const testKey = 'ginko_session_test_' + Date.now();
                const testValue = 'session_test_value_' + Math.random();
                
                sessionStorage.setItem(testKey, testValue);
                const retrieved = sessionStorage.getItem(testKey);
                sessionStorage.removeItem(testKey);
                
                if (retrieved === testValue) {
                    log(resultId, '‚úÖ sessionStorage read/write successful', 'success');
                    testResults.sessionStorage = true;
                } else {
                    log(resultId, '‚ùå sessionStorage data mismatch', 'error');
                    testResults.sessionStorage = false;
                }
            } catch (error) {
                log(resultId, `‚ùå sessionStorage failed: ${error.message}`, 'error');
                testResults.sessionStorage = false;
            }
        }

        function testCSPCompliance() {
            const resultId = 'csp-result';
            document.getElementById(resultId).innerHTML = '';
            
            log(resultId, 'Testing CSP compliance...', 'info');
            
            // Test 1: Try to execute inline script (should be blocked)
            try {
                const script = document.createElement('script');
                script.innerHTML = 'console.log("CSP inline script test");';
                document.head.appendChild(script);
                log(resultId, '‚ö†Ô∏è Inline script execution allowed (potential CSP issue)', 'warning');
            } catch (error) {
                log(resultId, '‚úÖ Inline script blocked (CSP working)', 'success');
            }
            
            // Test 2: Try to load external resource (should follow CSP rules)
            try {
                const img = new Image();
                img.onload = () => log(resultId, '‚úÖ External image loading allowed', 'success');
                img.onerror = () => log(resultId, '‚ö†Ô∏è External image loading blocked', 'warning');
                img.src = 'https://httpbin.org/image/png?_t=' + Date.now();
            } catch (error) {
                log(resultId, `External resource test error: ${error.message}`, 'info');
            }
            
            // Test 3: Check CSP headers
            try {
                const metas = document.querySelectorAll('meta[http-equiv="Content-Security-Policy"]');
                if (metas.length > 0) {
                    metas.forEach((meta, index) => {
                        log(resultId, `CSP Meta ${index + 1}: ${meta.content.substring(0, 100)}...`, 'info');
                    });
                } else {
                    log(resultId, 'No CSP meta tags found', 'info');
                }
            } catch (error) {
                log(resultId, `CSP header check error: ${error.message}`, 'error');
            }
            
            testResults.cspCompliance = true;
        }

        function testDOMAccess() {
            const resultId = 'dom-result';
            document.getElementById(resultId).innerHTML = '';
            
            log(resultId, 'Testing DOM access...', 'info');
            
            // Test 1: Basic DOM queries
            try {
                const elements = document.querySelectorAll('*');
                log(resultId, `‚úÖ DOM query successful: ${elements.length} elements found`, 'success');
                
                const divs = document.querySelectorAll('div');
                log(resultId, `‚úÖ Specific element query: ${divs.length} divs found`, 'success');
                
                testResults.domQuery = true;
            } catch (error) {
                log(resultId, `‚ùå DOM query failed: ${error.message}`, 'error');
                testResults.domQuery = false;
            }
            
            // Test 2: DOM manipulation
            try {
                const testElement = document.createElement('div');
                testElement.id = 'ginko-test-element';
                testElement.style.display = 'none';
                testElement.textContent = 'Ginko test element';
                
                document.body.appendChild(testElement);
                
                const retrieved = document.getElementById('ginko-test-element');
                if (retrieved) {
                    log(resultId, '‚úÖ DOM manipulation successful', 'success');
                    document.body.removeChild(testElement);
                    testResults.domManipulation = true;
                } else {
                    log(resultId, '‚ùå DOM manipulation failed - element not found', 'error');
                    testResults.domManipulation = false;
                }
            } catch (error) {
                log(resultId, `‚ùå DOM manipulation failed: ${error.message}`, 'error');
                testResults.domManipulation = false;
            }
            
            // Test 3: MutationObserver
            try {
                let observerWorks = false;
                const observer = new MutationObserver((mutations) => {
                    observerWorks = true;
                    log(resultId, '‚úÖ MutationObserver triggered successfully', 'success');
                    observer.disconnect();
                });
                
                const targetElement = document.body;
                observer.observe(targetElement, { childList: true, subtree: true });
                
                // Trigger a mutation
                const triggerElement = document.createElement('span');
                triggerElement.style.display = 'none';
                document.body.appendChild(triggerElement);
                
                setTimeout(() => {
                    if (triggerElement.parentNode) {
                        triggerElement.parentNode.removeChild(triggerElement);
                    }
                    if (!observerWorks) {
                        log(resultId, '‚ö†Ô∏è MutationObserver did not trigger', 'warning');
                    }
                    observer.disconnect();
                }, 100);
                
                testResults.mutationObserver = true;
            } catch (error) {
                log(resultId, `‚ùå MutationObserver test failed: ${error.message}`, 'error');
                testResults.mutationObserver = false;
            }
        }

        function testPerformance() {
            const resultId = 'performance-result';
            document.getElementById(resultId).innerHTML = '';
            
            log(resultId, 'Testing performance impact...', 'info');
            
            // Test 1: DOM query performance
            const startTime = performance.now();
            
            for (let i = 0; i < 1000; i++) {
                document.querySelectorAll('div, span, p, button');
            }
            
            const endTime = performance.now();
            const queryTime = endTime - startTime;
            
            log(resultId, `DOM query performance: ${queryTime.toFixed(2)}ms for 1000 queries`, 'info');
            
            if (queryTime < 100) {
                log(resultId, '‚úÖ Good performance (< 100ms)', 'success');
            } else if (queryTime < 500) {
                log(resultId, '‚ö†Ô∏è Moderate performance (100-500ms)', 'warning');
            } else {
                log(resultId, '‚ùå Poor performance (> 500ms)', 'error');
            }
            
            // Test 2: Memory usage (rough estimation)
            if (performance.memory) {
                const memory = performance.memory;
                log(resultId, `Memory usage: ${(memory.usedJSHeapSize / 1024 / 1024).toFixed(2)}MB used`, 'info');
                log(resultId, `Memory limit: ${(memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2)}MB limit`, 'info');
            } else {
                log(resultId, 'Memory usage information not available', 'info');
            }
            
            testResults.performance = { queryTime, timestamp: Date.now() };
        }

        // Set up CSP violation monitoring
        document.addEventListener('securitypolicyviolation', (e) => {
            console.warn('CSP Violation detected:', e);
            if (document.getElementById('csp-result')) {
                log('csp-result', `üö® CSP Violation: ${e.violatedDirective} - ${e.blockedURI}`, 'error');
            }
        });

        // Initial setup
        console.log('Ginko Manual Test Suite loaded');
        console.log('Available test functions:', {
            testExtensionPresence,
            testClipboard,
            testStorage,
            testCSPCompliance,
            testDOMAccess,
            testPerformance
        });
    </script>
</body>
</html>