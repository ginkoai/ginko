/**
 * @fileType: service
 * @status: current
 * @updated: 2025-09-09
 * @tags: [insights, ai, extraction, analysis]
 * @related: [../types/session.ts, ./module-generator.ts]
 * @priority: critical
 * @complexity: high
 * @dependencies: [../utils/ai-templates.ts]
 */

import { v4 as uuidv4 } from 'uuid';
import {
  SessionData,
  SessionInsight,
  InsightType,
  ExtractionOptions,
  ExtractionResult,
  CodeExample
} from '../types/session.js';
import { createAIService, BaseAIService } from './ai-service.js';

/**
 * Service for extracting insights from session data using AI
 */
export class InsightExtractor {
  private readonly defaultOptions: ExtractionOptions = {
    maxInsights: 6,
    minReusabilityScore: 0.7,
    minTimeSaving: 30, // minutes
    includeCodeExamples: true,
    verbose: false
  };
  
  private aiService: BaseAIService;
  
  constructor(aiService?: BaseAIService) {
    this.aiService = aiService || createAIService();
  }
  
  /**
   * Extract insights from session data
   */
  async extractInsights(
    sessionData: SessionData,
    options: ExtractionOptions = {}
  ): Promise<ExtractionResult> {
    const startTime = Date.now();
    const opts = { ...this.defaultOptions, ...options };
    
    try {
      // Build comprehensive prompt
      const prompt = this.buildExtractionPrompt(sessionData, opts);
      
      // Send to AI for analysis (this would use the actual AI adapter)
      const rawInsights = await this.analyzeWithAI(prompt, opts);
      
      // Parse and validate insights
      const insights = this.parseInsights(rawInsights, sessionData);
      
      // Filter by quality scores
      const filteredInsights = this.filterHighValueInsights(insights, opts);
      
      // Rank and limit insights
      const finalInsights = this.rankAndLimitInsights(filteredInsights, opts.maxInsights!);
      
      // Generate summary
      const summary = this.generateSummary(finalInsights, sessionData);
      
      return {
        insights: finalInsights,
        modules: [], // Modules will be generated by ModuleGenerator
        summary,
        processingTime: Date.now() - startTime
      };
    } catch (error) {
      return {
        insights: [],
        modules: [],
        summary: 'Failed to extract insights',
        processingTime: Date.now() - startTime,
        errors: [error instanceof Error ? error.message : String(error)]
      };
    }
  }
  
  /**
   * Build comprehensive prompt for AI analysis
   */
  private buildExtractionPrompt(sessionData: SessionData, options: ExtractionOptions): string {
    const filesChanged = sessionData.filesChanged
      .map(f => `  - ${f.path} (${f.status}, +${f.insertions}/-${f.deletions})`)
      .join('\n');
    
    const recentCommits = sessionData.commits
      .slice(0, 10)
      .map(c => `  - ${c.message}`)
      .join('\n');
    
    const testInfo = sessionData.testResults
      ?.map(t => `  - ${t.framework}: ${t.passed} passed, ${t.failed} failed`)
      .join('\n') || '  - No test results available';
    
    const errorInfo = sessionData.errorLogs
      ?.slice(0, 5)
      .map(e => `  - ${e.level}: ${e.message}`)
      .join('\n') || '  - No errors logged';
    
    return `You are analyzing a development session to extract pivotal learning moments that should be preserved for future reference.

# Session Information

**Duration**: ${sessionData.duration} minutes
**Work Mode**: ${sessionData.workMode}
**Branch**: ${sessionData.branch}

## Files Changed
${filesChanged}

## Recent Commits
${recentCommits}

## Test Results
${testInfo}

## Errors Encountered
${errorInfo}

## Git Diff Summary
- Staged changes: ${sessionData.stagedDiff ? 'Yes' : 'No'}
- Unstaged changes: ${sessionData.diff ? 'Yes' : 'No'}

# Task

Identify 3-6 insights that have lasting value. Focus on moments that would save time if remembered in future sessions.

For each insight, provide:
1. **Type**: gotcha | pattern | decision | discovery | optimization | workaround | configuration
2. **Title**: Brief, searchable title (5-10 words)
3. **Problem**: What challenge or question was faced? (1-2 sentences)
4. **Solution**: How was it resolved? (2-3 sentences)
5. **Impact**: What time/effort does this save in future? (1 sentence)
6. **Reusability Score**: 0.0-1.0 (How likely to encounter again?)
7. **Time Saving**: Minutes saved if remembered (number)
8. **Code Example**: Before/after code if applicable
9. **Prevention**: How to avoid this issue in future (1 sentence)
10. **Tags**: Relevant keywords for discovery

## Filtering Criteria
- Would forgetting this cause rework? (must be yes)
- Will this save >${options.minTimeSaving} minutes if remembered? (should be yes)
- Is this specific to current project only? (should be no)
- Reusability score must be >${options.minReusabilityScore}

## Output Format
Return a JSON array of insights with the structure defined above. Focus on quality over quantity - only include truly valuable insights.

Example insight:
{
  "type": "gotcha",
  "title": "React hooks must be called unconditionally",
  "problem": "useState was called inside an if statement causing 'Rendered more hooks than during previous render' error",
  "solution": "Moved useState call to top level of component, using conditional logic only for the state value updates",
  "impact": "Saves 30-60 minutes of debugging React hook errors",
  "reusabilityScore": 0.95,
  "timeSaving": 45,
  "codeExample": {
    "language": "typescript",
    "before": "if (condition) { const [state, setState] = useState(initialValue); }",
    "after": "const [state, setState] = useState(initialValue);\nif (condition) { setState(newValue); }"
  },
  "prevention": "Always call hooks at the top level of React functions",
  "tags": ["react", "hooks", "useState", "conditional", "error"]
}`;
  }
  
  /**
   * Analyze with AI
   */
  private async analyzeWithAI(prompt: string, options: ExtractionOptions): Promise<any> {
    try {
      // Use the AI service to extract insights
      const insights = await this.aiService.extractJSON(prompt);
      
      // Validate that we got an array back
      if (!Array.isArray(insights)) {
        console.warn('AI returned non-array response, wrapping in array');
        return [insights];
      }
      
      return insights;
    } catch (error) {
      // If AI service fails, log the error and return fallback insights
      if (options.verbose) {
        console.error('AI service error:', error);
        console.log('Falling back to example insights');
      }
      
      // Return example insights as fallback
      return [
        {
          type: 'gotcha',
          title: 'Vercel serverless functions need explicit API route exports',
          problem: 'API routes returning 404 despite correct file placement',
          solution: 'Changed from default export to named exports (GET, POST) in route.ts files for App Router compatibility',
          impact: 'Saves 1-2 hours debugging Next.js 13+ API routes',
          reusabilityScore: 0.9,
          timeSaving: 90,
          codeExample: {
            language: 'typescript',
            before: 'export default function handler(req, res) { }',
            after: 'export async function GET(request: Request) { }\nexport async function POST(request: Request) { }'
          },
          prevention: 'Always use named exports for HTTP methods in App Router API routes',
          tags: ['nextjs', 'api', 'vercel', 'app-router', 'serverless']
        },
        {
          type: 'pattern',
          title: 'Use connection pooling for serverless database access',
          problem: 'Database connections exhausted in production with serverless functions',
          solution: 'Implemented singleton pattern for database connection pool, reusing connections across function invocations',
          impact: 'Prevents production database connection failures',
          reusabilityScore: 0.85,
          timeSaving: 120,
          codeExample: {
            language: 'typescript',
            before: 'const db = new DatabaseClient(config);',
            after: 'let db: DatabaseClient;\nif (!db) { db = new DatabaseClient(config); }'
          },
          prevention: 'Always use connection pooling with serverless architectures',
          tags: ['database', 'serverless', 'connection-pool', 'production', 'singleton']
        }
      ];
    }
  }
  
  /**
   * Parse raw insights from AI response
   */
  private parseInsights(rawInsights: any, sessionData: SessionData): SessionInsight[] {
    if (!Array.isArray(rawInsights)) {
      return [];
    }
    
    return rawInsights.map(raw => ({
      id: uuidv4(),
      type: this.validateInsightType(raw.type),
      title: String(raw.title || 'Untitled Insight'),
      problem: String(raw.problem || ''),
      solution: String(raw.solution || ''),
      impact: String(raw.impact || ''),
      reusabilityScore: this.validateScore(raw.reusabilityScore),
      timeSavingPotential: Number(raw.timeSaving) || 30,
      relevanceScore: this.calculateRelevance(raw, sessionData),
      codeExample: this.parseCodeExample(raw.codeExample),
      preventedError: raw.prevention,
      relatedFiles: this.extractRelatedFiles(raw, sessionData),
      dependencies: raw.dependencies || [],
      tags: Array.isArray(raw.tags) ? raw.tags : [],
      sessionId: sessionData.userEmail + '-' + sessionData.sessionEnd.getTime(),
      timestamp: new Date()
    }));
  }
  
  /**
   * Validate insight type
   */
  private validateInsightType(type: any): InsightType {
    const validTypes: InsightType[] = [
      'gotcha', 'pattern', 'decision', 'discovery', 
      'optimization', 'workaround', 'configuration'
    ];
    
    if (validTypes.includes(type)) {
      return type;
    }
    
    return 'discovery'; // Default
  }
  
  /**
   * Validate score between 0 and 1
   */
  private validateScore(score: any): number {
    const num = Number(score);
    if (isNaN(num)) return 0.5;
    return Math.max(0, Math.min(1, num));
  }
  
  /**
   * Calculate relevance score based on session context
   */
  private calculateRelevance(insight: any, sessionData: SessionData): number {
    let score = 0.5; // Base score
    
    // Boost if related to files that were changed
    if (sessionData.filesChanged.some(f => 
      insight.tags?.some((tag: string) => f.path.includes(tag))
    )) {
      score += 0.2;
    }
    
    // Boost if related to errors encountered
    if (sessionData.errorLogs && sessionData.errorLogs.length > 0) {
      score += 0.15;
    }
    
    // Boost if related to test failures
    if (sessionData.testResults?.some(t => t.failed > 0)) {
      score += 0.15;
    }
    
    return Math.min(1, score);
  }
  
  /**
   * Parse code example from raw data
   */
  private parseCodeExample(raw: any): CodeExample | undefined {
    if (!raw || typeof raw !== 'object') {
      return undefined;
    }
    
    return {
      language: String(raw.language || 'typescript'),
      before: raw.before ? String(raw.before) : undefined,
      after: String(raw.after || ''),
      explanation: raw.explanation ? String(raw.explanation) : undefined
    };
  }
  
  /**
   * Extract files related to the insight
   */
  private extractRelatedFiles(insight: any, sessionData: SessionData): string[] {
    const related: string[] = [];
    
    // Check if any changed files match insight tags
    sessionData.filesChanged.forEach(file => {
      const fileLower = file.path.toLowerCase();
      insight.tags?.forEach((tag: string) => {
        if (fileLower.includes(tag.toLowerCase())) {
          related.push(file.path);
        }
      });
    });
    
    return [...new Set(related)]; // Remove duplicates
  }
  
  /**
   * Filter insights by quality scores
   */
  private filterHighValueInsights(
    insights: SessionInsight[],
    options: ExtractionOptions
  ): SessionInsight[] {
    return insights.filter(insight => 
      insight.reusabilityScore >= (options.minReusabilityScore || 0.7) &&
      insight.timeSavingPotential >= (options.minTimeSaving || 30)
    );
  }
  
  /**
   * Rank insights by combined score and limit to max
   */
  private rankAndLimitInsights(
    insights: SessionInsight[],
    maxInsights: number
  ): SessionInsight[] {
    // Calculate combined score for ranking
    const scored = insights.map(insight => ({
      insight,
      score: (
        insight.reusabilityScore * 0.4 +
        insight.relevanceScore * 0.3 +
        Math.min(insight.timeSavingPotential / 100, 1) * 0.3
      )
    }));
    
    // Sort by score descending
    scored.sort((a, b) => b.score - a.score);
    
    // Return top N insights
    return scored.slice(0, maxInsights).map(s => s.insight);
  }
  
  /**
   * Generate summary of insights
   */
  private generateSummary(insights: SessionInsight[], sessionData: SessionData): string {
    if (insights.length === 0) {
      return `No significant insights captured from ${sessionData.duration} minute ${sessionData.workMode} session.`;
    }
    
    const totalTimeSaving = insights.reduce((sum, i) => sum + i.timeSavingPotential, 0);
    const hours = Math.floor(totalTimeSaving / 60);
    const minutes = totalTimeSaving % 60;
    const timeStr = hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;
    
    const insightTypes = [...new Set(insights.map(i => i.type))].join(', ');
    
    return `Captured ${insights.length} valuable insights from ${sessionData.duration} minute ${sessionData.workMode} session. ` +
           `Types: ${insightTypes}. ` +
           `Potential time saved in future: ${timeStr}.`;
  }
}